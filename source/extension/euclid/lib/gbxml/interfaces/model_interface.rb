# Copyright (c) 2017 Big Ladder Software LLC. All rights reserved.
# See the file "license.txt" for additional terms and conditions.

require("euclid/lib/legacy_openstudio/lib/Collection")

require("euclid/lib/gbxml/interfaces/location_interface")
require("euclid/lib/gbxml/interfaces/detached_shading_surface_interface")

#require("euclid/lib/legacy_openstudio/lib/interfaces/DetachedShadingSurface")

#require("euclid/lib/legacy_openstudio/lib/observers/ModelObserver.rb")
#require("euclid/lib/legacy_openstudio/lib/observers/ModelEntitiesObserver.rb")


module Euclid
  module GbXML

    class ModelInterface

      attr_accessor :input_file, :model, :model_path
      attr_accessor :parent, :children, :observer, :entities_observer   # for debugging only


      def initialize(input_file = nil)
        @parent = nil
        @children = LegacyOpenStudio::Collection.new  # GlobalGeometryRules, Building, Location, Zones, and Shading Groups

        @input_file = input_file
        @model = Sketchup.active_model
        @model_path = Sketchup.active_model.path

        @observer = nil
        @entities_observer = nil

        @class_hash = Hash.new
        @draw_order = []
      end


      def inspect
        return(to_s)
      end


      # Check for initial errors that could be bad for drawing the input file.
      # Child drawing interfaces check each input object separately.
      def check_input_file
        return(true)
      end


      def on_change_input_file_path
        if (Sketchup.active_model and @input_file)
          @model.input_file_path = @input_file.path
        end
      end


      def draw_model(update_progress = nil)
        if (check_input_file)
          update_model(update_progress)
          #check_model  # bad do check here.  observers have already been added.
        end
        return(true)
      end


      # Updates the model with the current state of the input file.
      # This method does all of the drawing of new entities or updating of existing entities.
      def update_model(update_progress = nil)
        remove_observers

        @model.input_file_path = @input_file.path  # similar to:  @entity.input_object_key = @input_object.key

        # Loop through the input file and create an interface for each drawable input object.
        # Input objects that do not have a corresponding drawing interface are ignored.
        drawing_interfaces = Array.new


        # Reconstruct all the DetachedShadingGroup interfaces.  Because they are not derived from input objects,
        # they must be artificially reassociated with the groups around detached shading surfaces.
#        shading_interfaces = drawing_interfaces.find_all { |interface| interface.class == LegacyOpenStudio::DetachedShadingSurface }
#        for drawing_interface in shading_interfaces
#
#          if (drawing_interface.entity)
#            group = drawing_interface.entity.parent.instances.first
#            if (not group.drawing_interface)
#              shading_interface = LegacyOpenStudio::DetachedShadingGroup.new_from_entity(group)
#              shading_interface.surface_type = drawing_interface.surface_type
#            end
#          end
#        end

        # Loop through the document and create an interface for each drawable object.
        drawing_interfaces << LocationInterface.new_from_input_object(@input_file.document.location)

        for shading_surface in @input_file.document.shading_surfaces
          drawing_interfaces << DetachedShadingSurfaceInterface.new_from_input_object(shading_surface)
        end


        # Draw all the drawing interfaces.  Existing entities will be updated which may even erase and redraw.
        count = drawing_interfaces.length
        drawing_interfaces.each_with_index { |interface, i|
          if (update_progress)
            update_progress.call((100 * i / count), "Drawing Objects")
          end
          interface.draw_entity(false)  # False indicates not to use observers; they are added in bulk later.
        }

        if (update_progress)
          update_progress.call(100, "Finalizing Drawing")
        end

        check_model

        # After everything is drawn and finished changing, add the observer classes.
        add_observers
      end


      # Final check for any errors (generated by the plugin) in the drawing after opening a file.
      def check_model
        recurse_children.each { |child| child.cleanup_entity }
      end


      def erase_model
        remove_observers  # This really speeds up the erase when deleting many entities at once

        entities = @children.collect { |interface| interface.entity if (interface.valid_entity? and (interface.class == DetachedShadingGroupInterface)) }

        @model.close_active
        @model.entities.erase_entities(entities.to_a)
      end


      def clean_model
        recurse_children.each { |interface| interface.clean_entity }
      end


      def on_save_model
        @model_path = Sketchup.active_model.path
      end


      def add_observers
        recurse_children.each { |interface| interface.add_observers }
        @model.entities.add_observer(@entities_observer = LegacyOpenStudio::ModelEntitiesObserver.new)
      end


      def remove_observers
        if (@entities_observer)
          @model.entities.remove_observer(@entities_observer)
        end
        recurse_children.each { |interface| interface.remove_observers }
      end


      def add_child(child)
        @children.add(child)
      end


      def remove_child(child)
        @children.remove(child)
      end


      def recurse_children
        interfaces = LegacyOpenStudio::Collection.new(@children)
        @children.each { |interface| interfaces.merge(interface.recurse_children) }
        return(interfaces)
      end


      def has_surface_groups?
        for entity in @model.entities
          next if (entity.class != Sketchup::Group)
          return(true) if (entity.input_object_key)
        end
        return(false)
      end


    end

  end
end
